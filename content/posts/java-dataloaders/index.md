---
title: "Using java-dataloader to fix N+1 queries in a GraphQL API"
draft: true
date: 2023-10-18T06:00:00+01:00
tags: 
- Java
- SQL
- Data loaders
- GraphQL
- Performance - Spring Boot
categories:
- GraphQL
description: "TODO"
images: []
resources:
- name: "featured-image"
  src: "featured-image.png"
---

<!--more-->

This post will help you understand the N+1 query problem in a GraphQL API and show you how to use [java-dataloader](https://github.com/graphql-java/java-dataloader)
to fix this problem. Personally I have used this library for one of my clients that ran into performance issues. **It improved the performance by
around 60% to 80%!** These improvements made sure they could build further upon a solid base.

## The N+1 Query problem

Choosing to build a GraphQL API over a REST API can help avoid overfetching and your API will be less prone to backwards-incompatible schema changes. But
building a GraphQL API without keeping an eye on your database queries might lead to accidently building a very inefficient API call. This might happen because:

- Your resolvers are inefficient
- The frontend does a giant recursive fetch of the whole Graph in one API call, instead of multiple smaller (paginated) API calls

#### Let's look at an example

Imagine we have a simple data model containing `books`, `authors` and `reviews`.

An *author* can have multiple *books*, a *book* can have multiple *reviews*.

The frontend does the following API call to load the page's data:

```graphql
query {
  author(id: "1") {
    name
    books {
        name
        reviews {
            text
        }
    }
  }
}
```

Creating simple resolvers without data loaders will result in an N+1 fetch. The SQL that will be generated by using JPA relationships in your resolver will look
something like the following:


```sql
SELECT id, name FROM authors WHERE id = 1;

SELECT id, name FROM books WHERE author_id = 1;
/* Query above gives the following book ID's: [1, 2, 3] */

SELECT id, name FROM reviews WHERE id = 1;
SELECT id, name FROM reviews WHERE id = 2;
SELECT id, name FROM reviews WHERE id = 3;
/* etc... */

/* For each ID, a separate query is executed */
```
^ *Simplified pseudo-SQL to get the point across:*

As you can see, a new query is generated for each ID. In this case it is only 3 records, but in a larger application this can result in thousands of unnessecary
queries. This results in a lot of load on the database and it will make your API call slow. In the case of my client it resulted in bad performance or even brief
periods of database downtime.

This happens because GraphQL resolvers always assume you're calling them with a single ID. To fetch a list of records, you will need to implement some kind of batch
loading - for which we are going to use [java-dataloader](https://github.com/graphql-java/java-dataloader).

## Using java-dataloader

First, add the java-dataloader dependency to your project using the [official installation instructions](https://github.com/graphql-java/java-dataloader#installing). 

Okay, so let's quicky go over our resolver setup. In my clients codebase, the resolver was set up like this:

```java
@Component
@RequiredArgsConstructor
public class BookResolver implements GraphQLResolver<Review> {
  public List<Review> getReviews(Book book) {
    return book.getReviews();
  }
}
```
^ *The old resolver*

So this resolver is being called for each book ID that we fetched. As the code is executed in real time, there is no way to combine the database calls using this
code. We don't know if there will be only one call, multiple calls or how long the list of ID's is.

What will happen is:

![Scenario 1: Naive Resolver](./naive-resolver.png)

This is the reason GraphQL came up with [batch loading](https://docs.gitlab.com/ee/development/graphql_guide/batchloader.html). As we are using a Java Spring Boot
API in this example, we will use [java-dataloader](https://github.com/graphql-java/java-dataloader) to implement batch loading.

To start using data loaders, we will have to create two things:

- A data loader registry
- A data loader

#### Creating the data loader registry

In my clients' codebase, there was already a `com.client.backend.graphql` Java package. So to keep everything neat and tidy, we will create a new `com.client.backend.graphql.dataloader`
package. In here, we will create a factory to create a new data loader registry:

```java
@Component
public class DataLoaderRegistryFactory {

  private final ReviewRepository reviewRepository;

  // Needed because postgres allows a maximum of ~30000 query parameters.
  private static final int MAX_BATCH_SIZE = 30000;

  public DataLoaderRegistryFactory(ReviewRepository reviewRepository) {
    this.reviewRepository = reviewRepository;
  }


  public DataLoaderRegistry build() {
    var options = DataLoaderOptions.newOptions().setMaxBatchSize(MAX_BATCH_SIZE);

    var reviewDataLoader = DataLoaderFactory.newMappedDataLoader(new ReviewsBatchLoader(reviewRepository), options);

    return DataLoaderRegistry.newRegistry()
            .register(ReviewBatchLoader.KEY, reviewDataLoader)
            .build();
  }
}
```
*^ com.client.backend.graphql.dataloader.DataLoaderRegistryFactory*

This registry is needed to register our future data loaders. Just a bit of patience, we will create the ReviewBatchLoader shortly :wink:. This is also the place
where you can configure global settings for all your data loaders. Like for example the maximum batch size.

#### Creating a data loader

After we created the registry, we can create our first data loader. Let's look at the full code and then break each part of it down:

```java
public class ReviewsBatchLoader implements MappedBatchLoader<Integer, List<Review>> {

  public static final String KEY = "REVIEWS_BATCH_LOADER";

  private final ReviewRepository reviewRepository;

  public ReviewsBatchLoader(ReviewRepository reviewRepository) {
    this.reviewRepository = reviewRepository;
  }

  @Override
  public CompletionStage<Map<Integer, List<Review>>> load(Set<Integer> bookIds) {
    return CompletableFuture.supplyAsync(() -> {
      // If possible, return a map of { id: [Review] } straight out of the repository to avoid
      // having to build the map yourself.
      var reviews = reviewRepository.findAllByBookIdIn(bookIds.stream().toList());

      // If it's not possible to return a map directly from the repository, you can use something
      // like this to build the map yourself.
      return bookIds.stream()
              .collect(
                      HashMap::new,
                      (map, bookId) -> map.put(
                              bookId,
                              reviews.stream()
                                      .filter(review -> Objects.equals(bookId, review.getBook().getId()))
                                      .toList()
                      ),
                      HashMap::putAll
              );
    });
  }
}
```
*^ The implementation of our first data loader*

So let's go over each part of the batch loader to understand the code:

```java
public CompletionStage<Map<Integer, List<Review>>> load(Set<Integer> bookIds) {
}
```

The function signature is a bit complex, but will make sense after you give it a bit of thought. The return value is a [CompletionStage](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html)
which means that the result of this function is an asynchronous operation. The return value of the `CompletionStage` is a Map. An example of this map is:

```javascript
{
  /* BookId: [Review] */
  1: [review1, review2],
  2: [review5, review6, review9],
  3: [review4, review20]
}
```

The input argument of the `load` function is a `Set` of book ID's. This is **one batch** of ID's that the batch loader receives.

```java
@Component
@Slf4j
@RequiredArgsConstructor
public class BookResolver implements GraphQLResolver<Review> {
  public List<Zone> getZones(Installation installation, DataFetchingEnvironment environment) {
    var registry = environment.getDataLoaderRegistry();
    DataLoader<Integer, List<Zone>> dataLoader = registry.getDataLoader(ZonesBatchLoader.KEY);

    return dataLoader.load(installation.getId());
  }
}
```
*com.redacted.backend.graphql.resolvers*